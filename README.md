# Papers for Software Engineers

A curated list of papers that may be of interest to Software Engeneering students or professionals.

<br/>

1. **Computing Machinery and Intelligence**, [Turing (1950)](#https://phil415.pbworks.com/f/TuringComputing.pdf).
    * <small>ELIZAâ€”a computer program for the study of natural language communication between man and machine, [Weizenbaum (1966)](http://web.stanford.edu/class/cs124/p36-weizenabaum.pdf).</small>
1. **The Education of a Computer**, [Hopper (1952)](#https://people.cs.umass.edu/~emery/classes/cmpsci691st/readings/PL/p243-hopper.pdf).
1. **A Method for the Construction of Minimum-Redundancy Codes**, [Huffman (1952)](#https://www.ic.tu-berlin.de/fileadmin/fg121/Source-Coding_WS12/selected-readings/10_04051119.pdf).
    * <small>A Universal Algorithm for Sequential Data Compression, [Ziv, Lempel (1977)](https://courses.cs.duke.edu/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf).</small>
1. **A Note on Two Problems in Connexion with Graphs**, [Dijkstra (1959)](#http://www-m3.ma.tum.de/foswiki/pub/MN0506/WebHome/dijkstra.pdf).
    * <small>On the Shortest Spanning Subtree of a Graph and the Traveling Salesman Problem, [Kruskal (1956)](http://5010.mathed.usu.edu/Fall2018/THigham/Krukskal.pdf).</small>
1. **Recursive Functions of Symbolic Expressions and Their Computation by Machine**, [McCarthy (1960)](#http://jmc.stanford.edu/articles/recursive/recursive.pdf).
    * <small>The Art of the Interpreter, [Steele, Sussman (1978)](http://bitsavers.informatik.uni-stuttgart.de/pdf/mit/ai/aim/AIM-453.pdf).</small>
1. **Some Moral and Technical Consequences of Automation**, [Wiener (1960)](#https://nissenbaum.tech.cornell.edu/papers/Wiener.pdf).
1. **Cramming More Components onto Integrated Circuits**, [Moore (1965)](#https://newsroom.intel.com/wp-content/uploads/sites/11/2018/05/moores-law-electronics.pdf).
    * <small>Validity of the Single Processor Approach to Achieving Large-Scale Computing Capabilities, [Amdahl (1967)](https://www3.cs.stonybrook.edu/~rezaul/Spring-2012/CSE613/reading/Amdahl-1967.pdf).</small>
1. **Goto Statement Considered Harmful**, [Dijkstra (1968)](#https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf).
    * <small>Recursive Programming, [Dijkstra (1960)](https://www.ics.uci.edu/~jajones/INF102-S18/readings/07_dijkstra.pdf).</small>
    * <small>The Structure of the \"THE\"-Multiprogramming System, [Dijkstra (1968)](https://www.eecs.ucf.edu/~eurip/papers/dijkstra-the68.pdf).</small>
    * <small>Program development by stepwise refinement, [Wirth (1971)](http://sunnyday.mit.edu/16.355/wirth-refinement.html).</small>
1. **A Relational Model of Data for Large Shared Data Banks**, [Codd (1970)](#https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf).
1. **Space/Time Trade-offs in Hash Coding with Allowable Errors**, [Bloom (1970)](#https://cs.pwr.edu.pl/cichon/2021_22_a/BigData/Bloom.pdf).
    * <small>HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm, [Flajolet et al (2007)](http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf).</small>
1. **On the Criteria To Be Used in Decomposing Systems into Modules**, [Parnas (1971)](#https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf).
    * <small>Information Distribution Aspects of Design Methodology, [Parnas (1972)](https://cseweb.ucsd.edu/~wgg/CSE218/Parnas-IFIP71-information-distribution.PDF).</small>
    * <small>Designing Software for Ease of Extension and Contraction, [Parnas (1979)](https://courses.cs.washington.edu/courses/cse503/08wi/parnas-1979.pdf).</small>
    * <small>The Modular Structure of Complex Systems, [Parnas, Clements, Weiss (1984)](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.3812&rep=rep1&type=pdf).</small>
    * <small>Software Aging, [Parnas (1994)](https://www.cs.drexel.edu/~yfcai/CS451/RequiredReadings/SoftwareAging.pdf).</small>
1. **The UNIX Time- Sharing System**, [Ritchie, Thompson (1974)](#https://dsf.berkeley.edu/cs262/unix.pdf).
    * <small>Reflections on Trusting Trust, [Thompson (1984)](https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf).</small>
1. **A Protocol for Packet Network Intercommunication**, [Cerf, Kahn (1974)](#https://www.cs.princeton.edu/courses/archive/fall06/cos561/papers/cerf74.pdf).
    * <small>Ethernet: Distributed packet switching for local computer networks, [Metcalfe, Boggs (1978)](https://ethernethistory.typepad.com/papers/EthernetPaper.pdf).</small>
1. **Programming with Abstract Data Types**, [Liskov, Zilles (1974)](#https://dl.acm.org/doi/pdf/10.1145/942572.807045).
    * <small>A Design Methodology for Reliable Software Systems, [Liskov (1972)](https://dl.acm.org/doi/pdf/10.1145/1479992.1480018).</small>
    * <small>On understanding types, data abstraction, and polymorphism, [Cardelli, Wegner (1985)](https://dl.acm.org/doi/pdf/10.1145/6041.6042).</small>
    * <small>SELF: The Power of Simplicity, [Ungar, Smith (1991)](https://people.eecs.berkeley.edu/~fateman/264/papers/selfpower.ps).</small>


<br/>

This list was inspired by (and draws from) the [Papers We Love](https://paperswelove.org/) project and
the [Ideas That Created the Future](https://mitpress.mit.edu/books/ideas-created-future) book by Harry R. Lewis.
I also found [the morning paper](https://blog.acolyer.org/) blog to be an extremly useful resource.

## Selection criteria

1. The list should stay short. Let's say no more than 30 papers.
   - The idea is not to include every interesting paper that I come across but rather to keep a representative list that's possible to read from start to finish with a similar level of effort as reading a technical book from cover to cover.
   - I tried to include one paper per each major topic and author. Other related papers that I found interesting or noteworthy are included in sublists.
2. The papers shouldn't be too long. For the same reasons as the previous item, I try to avoid papers longer than 20 or 30 pages.
3. They should be self-contained and readable enough to be approachable by the casual technical reader.
4. They should be freely available online.
5. Although historical relevance was taken into account, I omitted seminal papers in the cases where I found them hard to approach, when the main subject of the paper wasn't the thing that made them influential, etc.
   - That being said, where possible I preferred the original paper on each subject over modern updates or summary papers.
6. I tended to prefer topics that I can relate to my professional practice, typically papers originated in the industry
or about innovations that later saw wide adoption. Likewise I tended to skip more theoretical papers, those focused on mathematical foundations for Computer Science,
on electronic aspects of hardware, etc.


Disclaimer: I'm not a frequent paper reader, so I made this list as a sort of roadmap for myself. I haven't read all of the papers in the list yet; as I do, I may find than some don't meet the described criteria after all and remove them, or decide to add new ones.

And, yes, this repository is a way to procrastinate on the actual reading after I finished making the list.

## Meta reads

TODO

